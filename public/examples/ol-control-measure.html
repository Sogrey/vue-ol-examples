<!--
CodeSandbox 分享文件
生成时间: 2025/11/23 18:21:28
页面标题: OpenLayers  测量控件
原始页面链接: https://sogrey.top/CodeSandbox/
-->

<!-- CodeSandbox Template File -->
<!-- 该文件包含完整的模板数据和设置信息，可以被重新导入 -->
<engine-type>openlayers</engine-type>
<title>OpenLayers  测量控件</title>
<meta name="description" content="本实例包含距离与面积测量。" />
<template>
<div id="map"></div>
<div class="measure-control" id="measure-control">
  <label>Geometry type &nbsp;</label>
  <select id="select-type">
    <option value="length">Length</option>
    <option value="area">Area</option>
  </select>
  <label class="checkbox">
    <input type="checkbox" id="geodesic" />use geodesic measures
  </label>
</div>
</template>
<script>
console.log(ol)

const gaodeLayer = new ol.layer.Tile({
  source: new ol.source.XYZ({
    title: '高德',
    url: 'http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}',
  }),
})

const map = new ol.Map({
  target: 'map',
  // 在加载瓦片图层时开启动画效果
  loadTilesWhileAnimate: true,
  loadTilesWhileInteracting: true,
  view: new ol.View({
    center: [11421771, 4288300],
    zoom: 8,
    worldsWrap: true,
    minZoom: 1,
    maxZoom: 20,
    projection: 'EPSG:3857',
  }),
  // 鼠标控件：鼠标在地图上移动时显示坐标信息。
  controls: ol.control.defaults.defaults().extend([
    // 加载鼠标控件
    new ol.control.MousePosition(),
  ]),
})
map.addLayer(gaodeLayer)

// =============================

// 创建矢量图层
const vectorSource = new ol.source.Vector()
const vectorLayer = new ol.layer.Vector({
  source: vectorSource,
  style: new ol.style.Style({
    fill: new ol.style.Fill({
      // 填充色
      color: 'rgba(255,255,255,0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: '#ffcc33', // 边线颜色
      width: 2.5 // 边线宽度
    }),
    // 顶点样式
    image: new ol.style.Circle({
      radius: 7,
      fill: new ol.style.Fill({
        color: '#ffcc33'
      })
    })
  })
})
map.addLayer(vectorLayer)

let draw = null // 绘制对象
let sketch = null // 当前绘制要素

let helpTooltipElement = null // 创建提示框
let helpTooltip = null

// 创建测量工具提示框
let measureTooltipElement = null
let measureTooltip = null

const geodesicCheckBox = document.getElementById('geodesic')
// 创建测量交互函数
const selectType = document.getElementById('select-type')
selectType.onchange = evt => {
  // 移除交互式控件
  if (draw) {
    map.removeInteraction(draw)
  }
  // 添加交互式控件进行测量
  addInteraction()
}
addInteraction()

function addInteraction() {
  const type = selectType.value === 'area' ? 'Polygon' : 'LineString'
  draw = new ol.interaction.Draw({
    source: vectorSource,
    type: type,
    style: new ol.style.Style({
      fill: new ol.style.Fill({
        color: "rgba(255,255,255,0.2)"
      }),
      stroke: new ol.style.Stroke({
        color: "#ffcc33",
        lineDash: [10, 10],
        width: 2
      }),
      image: new ol.style.Circle({
        radius: 5,
        fill: new ol.style.Fill({
          color: 'rgba(255,255,255,0.2)'
        })
      })
    })
  })
  map.addInteraction(draw)
  createMeasureTooltip() // 测量工具提示框
  createHelpTooltip() // 帮助信息提示框框
  let listener = null
  // 监听开始绘制事件
  draw.on('drawstart', function(evt) {
    // 绘制要素
    sketch = evt.feature
    // 绘制坐标
    let tooltipCoord = evt.coordinate
    // 绑定change事件，根据绘制几何图形类型得到测量距离或者面积，并将其添加到测量工具提示框
    listener = sketch.getGeometry().on('change', evt => {
      // 绘制的几何对象
      const geom = evt.target
      let output = 0
      if (geom instanceof ol.geom.Polygon) {
        output = formatArea(geom)
        tooltipCoord = geom.getInteriorPoint().getCoordinates()
      } else {
        output = formatLength(geom)
        tooltipCoord = geom.getLastCoordinate()
      }
      // 将测量值添加到提示框
      measureTooltipElement.innerHTML = output
      // 设置测量提示工具框的位置
      measureTooltip.setPosition(tooltipCoord)
    })
  }, this)

  draw.on('drawend', function(evt) {
    measureTooltipElement.className = 'tooltip tooltip-static'
    measureTooltip.setOffset([0, -7])
    sketch = null
    measureTooltipElement = null
    createMeasureTooltip()
    ol.Observable.unByKey(listener)
  }, this)
}

function createHelpTooltip() {
  if (helpTooltip) {
    helpTooltipElement.parentNode.removeChild(helpTooltipElement)
  }
  helpTooltipElement = document.createElement('div')
  helpTooltipElement.className = 'tooltip hidden'

  helpTooltip = new ol.Overlay({
    element: helpTooltipElement,
    offset: [15, 0],
    positioning: 'center-left'
  })
  map.addOverlay(helpTooltip)
}

function createMeasureTooltip() {
  if (measureTooltipElement) {
    measureTooltipElement.parentNode.removeChild(measureTooltipElement)
  }
  measureTooltipElement = document.createElement('div')
  measureTooltipElement.className = 'tooltip tooltip-measure'
  measureTooltip = new ol.Overlay({
    element: measureTooltipElement,
    offset: [0, -15],
    positioning: 'bottom-center'
  })
  map.addOverlay(measureTooltip)
}

// 创建面积与距离测算方法

function formatLength(line) {
  let length = 0
  if (geodesicCheckBox.checked) {
    // 经纬度测量，曲面面积
    const sourcePrj = map.getView().getProjection()
    length = ol.sphere.getLength(line, {
      'projection': sourcePrj,
      'radius': 678137
    })
  } else {
    length = Math.round(line.getLength() * 100) / 100
  }
  let output = 0;
  if (length > 100) {
    output = (Math.round(length / 1000 * 100) / 100) + ' ' + 'km'; //换算成KM单位
  } else {
    output = (Math.round(length * 100) / 100) + ' ' + 'm'; //m为单位
  }
  return output; //返回线的长度
}

function formatArea(polygon) {
  let area = 0;
  if (geodesicCheckBox.checked) { //若使用测地学方法测量
    const sourceProj = map.getView().getProjection(); //地图数据源投影坐标系
    const geom = (polygon.clone().transform(sourceProj, 'EPSG:4326')); //将多边形要素坐标系投影为EPSG:4326
    area = Math.abs(ol.sphere.getArea(geom, {
      "projection": sourceProj,
      "radius": 6378137
    })); //获取面积
  } else {
    area = polygon.getArea(); //直接获取多边形的面积
  }
  let output = 0;
  if (area > 10000) {
    output = (Math.round(area / 1000000 * 100) / 100) + ' ' + 'km<sup>2</sup>'; //换算成KM单位
  } else {
    output = (Math.round(area * 100) / 100) + ' ' + 'm<sup>2</sup>'; //m为单位
  }
  return output; //返回多边形的面积
};

// 添加地图鼠标移动事件
const drawPolygonMsg = "Click to continue drawing the polygon"
const drawLineMsg = "Click to continue drawing the line"
// 鼠标移动事件处理函数
const pointerMoveHandler = evt => {
  if (evt.dragging) {
    return
  }
  let helpMsg = "Click to start drawing" // 默认提示信息
  // 判断绘制的几何类型，设置对应信息提示框
  if (sketch) {
    const geom = sketch.getGeometry()
    if (geom instanceof ol.geom.Polygon) {
      helpMsg = drawPolygonMsg
    } else if (geom instanceof ol.geom.LineString) {
      helpMsg = drawLineMsg
    }
  }
  helpTooltipElement.innerHTML = helpMsg //

  helpTooltip.setPosition(evt.coordinate)
  helpTooltipElement.classList.remove('hidden') // 移除隐藏样式

}
map.on('pointermove', pointerMoveHandler) // 绑定鼠标移动事件，动态显示帮助信息提示框

var viewport = map.getViewport();

function handleMouseOut(event) {
  console.log('鼠标已移出地图！');
  console.log('事件类型:', event.type);
  console.log('目标元素:', event.target);

  helpTooltipElement.classList.add('hidden')
}

viewport.addEventListener('mouseout', handleMouseOut);
</script>
<style>
* {
  padding: 0;
  margin: 0;
  font-size: 14px;
  font-family: '微软雅黑';
}

html,
body {
  width: 100%;
  height: 100%;
}

#map {
  position: absolute;
  width: 100%;
  height: 100%;
}

.ol-zoom {
  position: absolute;
  right: 16px;
  bottom: 16px;
  top: auto;
  left: auto;
}

.measure-control {
  position: absolute;
  background: #434343a8;
  width: 30%;
  top: 24px;
  right: 16px;
  padding: 5px 10px;
  border-radius: 5px;
  color: #fff;
}

/*提示框信息样式*/
.tooltip {
  position: relative;
  background: rgba(0, 0, 0, .5);
  border-radius: 4px;
  color: #ffffff;
  padding: 4px 8px;
  opacity: 0.7;
  white-space: nowrap
}

.tooltip-measure {
  opacity: 1;
  font-weight: bold
}

.tooltip-static {
  background-color: #ffcc33;
  color: black;
  border: 1px solid white
}

.tooltip-measure:before,
.tooltip-static:before {
  border-top: 6px solid rgba(0, 0, 0, 0.5);
  border-right: 6px solid transparent;
  border-left: 6px solid transparent;
  content: "";
  position: absolute;
  bottom: -6px;
  margin-left: -7px;
  left: 50%;
}

.tooltip-static:before {
  border-top-color: #ffcc33;
}
</style>

<!-- Settings Section - 设置数据，将被自动解析 -->
<settings>
<head-metadata>

</head-metadata>
<css-links>

</css-links>
<js-links>

</js-links>
</settings>
